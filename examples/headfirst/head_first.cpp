// auto-generated by x2boost xpiler

#include "head_first.hpp"

#include <boost/functional/hash.hpp>
#include <boost/thread/once.hpp>

#include <x2boost/event_factory.hpp>

using namespace x2::examples::head_first;

namespace
{
    x2::event::tag capitalize_req_tag;
    boost::once_flag capitalize_req_once = BOOST_ONCE_INIT;
    void capitalize_req_init()
    {
        capitalize_req_tag.set(x2::event::_tag(), 1, 1);
    }

    struct static_capitalize_req_initializer
    {
        static_capitalize_req_initializer()
        {
            x2::event_factory::enroll(1,
                (x2::event_factory::func_type)capitalize_req::_new); 
        }
    };
    static_capitalize_req_initializer static_capitalize_req_init;
}

bool capitalize_req::_equals(const x2::cell& other) const
{
    if (!x2::event::_equals(other))
    {
        return false;
    }
    const capitalize_req& o = static_cast<const capitalize_req&>(other);
    if (message_ != o.message_)
    {
        return false;
    }
    return true;
}

bool capitalize_req::_equivalent(const x2::cell& other) const
{
    if (!x2::event::_equivalent(other))
    {
        return false;
    }
    const capitalize_req& o = static_cast<const capitalize_req&>(other);
    x2::capo touched(x2::cell::fingerprint_, _tag()->offset());
    if (touched[0] && message_ != o.message_)
    {
        return false;
    }
    return true;
}

std::size_t capitalize_req::_hash_code(const x2::fingerprint& fp) const
{
    std::size_t value = x2::event::_hash_code(fp);
    x2::capo touched(fp, _tag()->offset());
    if (touched[0])
    {
        boost::hash_combine(value, message_);
    }
    return value;
}

void capitalize_req::_initialize()
{
    message_ = "";
}

const x2::event::tag* capitalize_req::_tag()
{
    boost::call_once(capitalize_req_init, capitalize_req_once);
    return &capitalize_req_tag;
}

const x2::cell::tag* capitalize_req::_type_tag() const
{
    return _tag();
}

void capitalize_req::_describe(std::ostringstream& oss) const
{
    x2::event::_describe(oss);
    oss << " message=" << message_;
}

namespace
{
    x2::event::tag capitalize_resp_tag;
    boost::once_flag capitalize_resp_once = BOOST_ONCE_INIT;
    void capitalize_resp_init()
    {
        capitalize_resp_tag.set(x2::event::_tag(), 1, 2);
    }

    struct static_capitalize_resp_initializer
    {
        static_capitalize_resp_initializer()
        {
            x2::event_factory::enroll(2,
                (x2::event_factory::func_type)capitalize_resp::_new); 
        }
    };
    static_capitalize_resp_initializer static_capitalize_resp_init;
}

bool capitalize_resp::_equals(const x2::cell& other) const
{
    if (!x2::event::_equals(other))
    {
        return false;
    }
    const capitalize_resp& o = static_cast<const capitalize_resp&>(other);
    if (result_ != o.result_)
    {
        return false;
    }
    return true;
}

bool capitalize_resp::_equivalent(const x2::cell& other) const
{
    if (!x2::event::_equivalent(other))
    {
        return false;
    }
    const capitalize_resp& o = static_cast<const capitalize_resp&>(other);
    x2::capo touched(x2::cell::fingerprint_, _tag()->offset());
    if (touched[0] && result_ != o.result_)
    {
        return false;
    }
    return true;
}

std::size_t capitalize_resp::_hash_code(const x2::fingerprint& fp) const
{
    std::size_t value = x2::event::_hash_code(fp);
    x2::capo touched(fp, _tag()->offset());
    if (touched[0])
    {
        boost::hash_combine(value, result_);
    }
    return value;
}

void capitalize_resp::_initialize()
{
    result_ = "";
}

const x2::event::tag* capitalize_resp::_tag()
{
    boost::call_once(capitalize_resp_init, capitalize_resp_once);
    return &capitalize_resp_tag;
}

const x2::cell::tag* capitalize_resp::_type_tag() const
{
    return _tag();
}

void capitalize_resp::_describe(std::ostringstream& oss) const
{
    x2::event::_describe(oss);
    oss << " result=" << result_;
}

// end of head_first.cpp
