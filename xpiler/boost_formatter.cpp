// Copyright (c) 2014 Jae-jun Kang
// See the file COPYING for license details.

#include "boost_formatter.hpp"

#include <fstream>

#include <boost/algorithm/string.hpp>
#include <boost/filesystem.hpp>

#include "document.hpp"

using namespace std;
using namespace xpiler;

namespace fs = boost::filesystem;

namespace
{
    void PascalCase2camelCase(string& s);
    string MixedCase2Under_Score(const string& s);
    string MixedCase2lower_case(const string& s);
    string MixedCase2UPPER_CASE(const string& s);
}

bool boost_formatter::format(document* doc, const string& out_dir)
{
    try
    {
        fs::path basename = out_dir;
        basename /= doc->basename;

        BoostHeaderformatter header_context;
        header_context.doc = doc;
        header_context.target = basename.string() + ".hpp";

        BoostSourceformatter source_context;
        source_context.doc = doc;
        source_context.target = basename.string() + ".cpp";

        format_header_file(header_context);
        format_source_file(source_context);

        return true;
    }
    catch (std::exception& e)
    {
        cout << e.what() << endl;
        return false;
    }
}

bool boost_formatter::is_up_to_date(const string& path)
{
    fs::path p = path;
    fs::path dirname = p.parent_path();
    fs::path basename = p.filename().stem();
    fs::path header_path = basename.string() + ".hpp";
    fs::path source_path = basename.string() + ".hpp";
    header_path = dirname / header_path;
    source_path = dirname / source_path;

    time_t source_write_time = fs::last_write_time(path);
    return (fs::exists(header_path) && fs::exists(source_path) &&
        fs::last_write_time(header_path) >= source_write_time &&
        fs::last_write_time(source_path) >= source_write_time);
}

void boost_formatter::format_header_file(formatter_context& context)
{
    ofstream out(context.target);
    context.out = &out;

    string include_guard;
    if (!context.doc->ns.empty())
    {
        include_guard = context.doc->ns;
        boost::replace_all(include_guard, ".", "_");
        include_guard.append("_");
    }
    include_guard += MixedCase2Under_Score(context.doc->basename);
    include_guard += "_HPP_";
    boost::to_upper(include_guard);

    out << "// auto-generated by x2boost xpiler" << endl;
    out << "#ifndef " << include_guard << endl;
    out << "#define " << include_guard << endl;

    out << "#endif  // " << include_guard << endl;

    out.close();
}

void boost_formatter::format_source_file(formatter_context& context)
{
    ofstream out(context.target);
    context.out = &out;

    out << "#include \"" << context.doc->basename + ".hpp\"" << endl;

    out << "// end of " << fs::path(context.target).filename().string() << endl;

    out.close();
}

void BoostHeaderformatter::format_cell(cell* def)
{

}

void BoostHeaderformatter::format_consts(consts* def)
{

}

void BoostHeaderformatter::format_reference(reference* def)
{

}

void BoostSourceformatter::format_cell(cell* def)
{

}

void BoostSourceformatter::format_consts(consts* def)
{

}

void BoostSourceformatter::format_reference(reference* def)
{

}

namespace
{
    void PascalCase2camelCase(string& s) {
        if (s.empty() || !::isupper(s[0]))
        {
            return;
        }
        string::iterator it = s.begin(), end = s.end(), next;
        *it++ = (char)::tolower(*it);
        next = it;
        if (next != end) { ++next; }
        while (it != end)
        {
            if (!::isupper(*it) || (next != end && !::isupper(*next)))
            {
                break;
            }
            *it++ = (char)::tolower(*it);
            if (next != end) { ++next; }
        }
    }

    string MixedCase2Under_Score(const string& s)
    {
        string result;
        if (!s.empty())
        {
            back_insert_iterator<string> out = back_inserter(result);
            string::const_iterator it = s.begin(), end = s.end(), prev, next;
            prev = it;
            *out++ = *it++;
            next = it;
            if (next != end) { ++next; }
            while (it != end)
            {
                if ((::islower(*prev) && ::isupper(*it)) || (next != end &&
                    ::isupper(*prev) && ::isupper(*it) && ::islower(*next)))
                {
                    *out++ = '_';
                }
                *out++ = *it++;
                ++prev;
                if (next != end) { ++next; }
            }
        }
        return result;
    }

    string MixedCase2lower_case(const string& s)
    {
        string result = MixedCase2Under_Score(s);
        boost::to_lower(result);
        return result;
    }

    string MixedCase2UPPER_CASE(const string& s)
    {
        string result = MixedCase2Under_Score(s);
        boost::to_upper(result);
        return result;
    }
}  // namespace

// EOF boost_formatter.cpp
